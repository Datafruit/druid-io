---
layout: doc_page
---

滚动更新
====================

滚动Druid集群更新没有停息时间,我们建议更新中的Druid节点，按照以下顺序：
1. 历史的
2. Overlord (如果有的话)
3. 中间管理层(如果有的话)
4. 独立的实时 (如果有的话)
5. 代理
6. 协调器

## 历史的

历史节点每次可以更新一个。每个历史节点内存映射所有的段在更新前启动服务。
启动时间通常需要几秒钟几分钟,这取决于节点的硬件。
只要每个历史节点更新足够的延迟(大于开始一个节点所需的时间),你可以滚动更新整个历史集群。

## Overlord

Overlord节点可以在滚动时更新。
## 中间管理层

中层管理层运行批处理和实时索引任务。通常你以这样一种方式更新中间管理层,那么实时索引任务不会失败。有三个策略可以这样做。

### 滚动重启（基于还原）

当你设置`druid.indexer.task.restoreTasksOnRestart = true`时，中层管理人员可以以滚动的方式更新。
在这种情况下,索引任务支持恢复，将在中层管理层重启恢复他们的状态,而且不会失败。

目前,只有实时任务支持恢复,非实时索引任务将会失败并且需要重新提交。

### 滚动重启（基于很好的终止）

中层管理层可以很好地终止使用“禁用”API。这适用于所有的任务类型,即使任务不恢复原状。

为了准备更新中间管理层,发送一个POST请求到`<MiddleManager_IP:PORT>/druid/worker/v1/disable`。
Overlord现在将不再发送任务到这个中间管理层。任务已经开始将运行完成。

查看现在所有的任务，发送一个GET请求到 `<MiddleManager_IP:PORT>/druid/worker/v1/tasks`。
当这个列表是空的时候，你可以安全地更新到中间管理层。中间管理层开始备份后，它可以能够再次自动启动。你也可以通过POSTing到启动中间管理者 `<MiddleManager_IP:PORT>/druid/worker/v1/enable`。

### 基于自动缩放替换

如果你的Overlord启用了自动缩放,Overlord节点可以推出大量的新中间管理层节点,然后优雅地终止旧的任务完成。
这个过程是通过设置`druid.indexer.runner.minWorkerVersion = # { VERSION }`配置。
每次你更新你的Overlord节点,应该增加`版本`值,这将引发大规模推出新的中间管理层。

`druid.indexer.autoscale.workerVersion=#{VERSION}`配置也需要设置。

## 独立的实时

独立的实时节点可以在滚动时更新。
## 代理

代理节点可以滚动的方式更新一次。更新每个节点之间需要一些延迟，作为代理必须在返回有效结果之前加载整个集群的状态。

## 协调器

协调器节点可以滚动的方式更新一次。